package aQute.bnd.eclipse;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Formatter;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import aQute.bnd.build.Project;
import aQute.bnd.build.model.BndEditModel;
import aQute.bnd.build.model.clauses.ExportedPackage;
import aQute.bnd.header.Parameters;
import aQute.bnd.osgi.Constants;
import aQute.bnd.properties.Document;
import aQute.bnd.service.lifecycle.LifeCyclePlugin;
import aQute.lib.io.IO;
import aQute.lib.strings.Strings;
import aQute.lib.tag.Tag;
import aQute.lib.utf8properties.UTF8Properties;

public class EclipseLifecyclePlugin extends LifeCyclePlugin {

	static Pattern PACKAGE_INFO_VERSION_MATCH_P = Pattern.compile("@.*\\.Version\\s*(\\s*\\\"([^\"]+)\"\\s*)\\s*;");

	@Override
	public void created(Project project) throws Exception {

		File cp = project.getFile(".classpath");
		if (!cp.isFile()) {
			Tag cpTag = toClasspathTag(project);
			IO.store(cpTag.toString(), cp);
		}

		File projectFile = project.getFile(".project");
		if (!projectFile.isFile()) {
			Tag projectTag = toProjectTag(project);
			IO.store(projectTag.toString(), projectFile);
		}

		super.created(project);
	}

	public static Tag toProjectTag(Project project) {
		Tag projectTag = new Tag("projectDescription");
		new Tag(projectTag, "name", project.getName());
		new Tag(projectTag, "commend", "generated by bnd");
		Tag buildSpec = new Tag(projectTag, "buildSpec");
		Tag buildCommand = new Tag(buildSpec, "buildCommand");
		new Tag(buildCommand, "name", "org.eclipse.jdt.core.javabuilder");
		buildCommand = new Tag(buildSpec, "buildCommand");
		new Tag(buildCommand, "name", "bndtools.core.bndbuilder");

		Tag natures = new Tag(projectTag, "natures");
		new Tag(natures, "nature", "org.eclipse.jdt.core.javanature");
		new Tag(natures, "nature", "bndtools.core.bndnature");

		Parameters extraNatures = new Parameters(project.getProperty("eclipse.natures"));
		for (String extraNature : extraNatures.keySet()) {
			new Tag(natures, "nature", extraNature);
		}

		return projectTag;
	}

	// <?xml version="1.0" encoding="UTF-8"?>
	// <classpath>
	// <classpathentry kind="src" output="bin" path="src"/>
	// <classpathentry kind="src" output="bin_test" path="test"/>
	// <classpathentry kind="con"
	// path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
	// <classpathentry kind="con" path="aQute.bnd.classpath.container"/>
	// <classpathentry kind="output" path="bin"/>
	// </classpath>

	public static Tag toClasspathTag(Project project) {

		String mainOutput = project.getProperty(Constants.DEFAULT_PROP_BIN_DIR);
		String testOutput = project.getProperty(Constants.DEFAULT_PROP_TESTBIN_DIR);

		List<String> mainSources = Strings.split(project.getProperty(Constants.DEFAULT_PROP_SRC_DIR));
		List<String> testSources = Strings.split(project.getProperty(Constants.DEFAULT_PROP_TESTSRC_DIR));
		List<String> mainResources = Strings.split(project.getProperty(Constants.DEFAULT_PROP_RESOURCES_DIR));
		List<String> testResources = Strings.split(project.getProperty(Constants.DEFAULT_PROP_RESOURCES_DIR));

		Tag top = new Tag("classpath");
		Tag jre = new Tag(top, "classpathentry");
		String javaTarget = project.getProperty("java.target", "1.8");

		if (!javaTarget.matches("\\d+\\.\\d+")) {
			project.error("Invalid java.target property. Is %s bust match like 1.8. Assuming 1.8", javaTarget);
			javaTarget = "1.8";
		}

		jre.addAttribute("kind", "con");
		jre.addAttribute("path",
				"org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-"
						+ javaTarget);

		Tag bnd = new Tag(top, "classpathentry");
		bnd.addAttribute("kind", "con");
		bnd.addAttribute("path", "aQute.bnd.classpath.container");

		Tag b = new Tag(top, "classpathentry");
		b.addAttribute("kind", "output");
		b.addAttribute("path", project.getProperty("bin"));

		doClassPathEntry(mainOutput, mainSources, top);
		doClassPathEntry(mainOutput, mainResources, top);
		doClassPathEntry(testOutput, testSources, top);
		doClassPathEntry(mainOutput, testResources, top);

		return top;
	}

	private static void doClassPathEntry(String mainOutput, List<String> mainSources, Tag top) {
		for (String mainSource : mainSources) {
			Tag s = new Tag(top, "classpathentry");
			s.addAttribute("kind", "src");
			s.addAttribute("path", mainSource);
			s.addAttribute("output", mainOutput);
		}
	}

	public static void moveExportedVersionsToJavaInfo(Project project) throws Exception {
		String bnd = IO.collect(project.getPropertiesFile());
		Document document = new Document(bnd);
		BndEditModel model = new BndEditModel();
		model.loadFrom(document);
		List<ExportedPackage> exportedPackages = model.getExportedPackages();
		if (exportedPackages == null)
			return;

		boolean changes = false;

		nextPackage: for (ExportedPackage exportedPackage : exportedPackages) {
			String packageDir = exportedPackage.getName().replace('.', '/');
			String manifestVersion = exportedPackage.getVersionString();
			if (manifestVersion != null) {
				for (File sourceDirectory : project.getSourcePath()) {

					File packageInfo = IO.getFile(sourceDirectory, packageDir + "/package-info.java");

					if (packageInfo.isFile()) {
						changes = doExistingJavaInfoPackage(project, changes, exportedPackage, manifestVersion,
								packageInfo);
						continue nextPackage;
					} else if (packageInfo.getParentFile().isDirectory()) {
						doCreatePackageInfo(packageInfo, packageDir, manifestVersion);
						exportedPackage.setVersionString(null);
						changes = true;
					}
				}
			}
		}
		if (changes)
			model.setExportedPackages(exportedPackages);

		model.saveChangesTo(document);
		bnd = document.get();
		IO.store(bnd, project.getPropertiesFile());
		project.refresh();
	}

	private static boolean doExistingJavaInfoPackage(Project p, boolean changes, ExportedPackage exportedPackage,
			String manifestVersion, File packageInfo) throws IOException {
		String content = IO.collect(packageInfo);
		Matcher m = PACKAGE_INFO_VERSION_MATCH_P.matcher(content);
		boolean hasVersionAnnotation = m.matches();
		if (hasVersionAnnotation) {
			String fileVersion = m.group(1);
			boolean manifestAndAnnotationAreSameVersion = manifestVersion.equals(fileVersion);
			if (manifestAndAnnotationAreSameVersion) {
				exportedPackage.setVersionString(null);
				changes = true;
			} else {
				p.warning("Different package version in bnd file %s", packageInfo);
			}
		} else /* no annotation in file */ {
			content = content.replaceAll("($|\n|\r)\\s*package\\s+",
					"\n@org.osgi.annotation.versioning.Version(\"" + manifestVersion + "\")\npackage ");
			IO.store(content, packageInfo);
		}
		return changes;
	}

	private static void doCreatePackageInfo(File packageInfoFile, String packg, String versionString)
			throws IOException {
		try (Formatter f = new Formatter()) {
			f.format("@org.osgi.annotation.versioning.Version(\"%s\")\n", versionString);
			f.format("package %s;\n", packg.replace('/', '.'));
			IO.store(f.toString(), packageInfoFile);
		}
	}

	public static void updateSettingsJDT(Project p) throws IOException {
		UTF8Properties props = new UTF8Properties();
		File pf = p.getFile(".settings/org.eclipse.jdt.core.prefs");
		if (pf.isFile()) {
			try (InputStream in = new FileInputStream(pf)) {
				props.load(in);
			}
		} else
			pf.getParentFile().mkdirs();

		String javactarget = p.getProperty(Constants.JAVAC_TARGET, "1.8");
		String javacSource = p.getProperty(Constants.JAVAC_SOURCE, "1.8");

		props.setProperty("org.eclipse.jdt.core.compiler.codegen.targetPlatform", javactarget);
		props.setProperty("org.eclipse.jdt.core.compiler.codegen.source", javacSource);
		props.setProperty("org.eclipse.jdt.core.compiler.codegen.compliance", javacSource);

		props.store(pf);
	}

}
